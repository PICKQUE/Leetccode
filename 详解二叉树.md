# 二叉树

二叉树的一些特征：
$$
n=n_1+n_2+n_0
$$
总节点的节点的度数之和加一
$$
n=n_1+2n_2+1
$$
然后两个可以推导出来这个公式
$$
n_2=n_0-1
$$
二叉树经常用到的四种遍历形式

## 先序遍历（前序遍历）

逻辑很简单，根->左节点->右节点
注意：每次访问下一棵子树的时候都是这种顺序，先根再左然后右。下面有图片解释

![前序遍历](/图片资源/前序遍历.jpg)

代码（这里的vist函数是泛称，指对当前根的一个操作函数，可以输出，可以计算）

```C++
    void PreOrder(TreeNode *root){
        if(root!=NULL){
            vist(root);//访问根节点
            PreOrder(root->left);//遍历左子树
            PreOrder(root->right);//遍历右子树
        }
    }
```

## 中序遍历

```md
**前序和中序遍历可以唯一的确定一颗二叉树**

前序和后序遍历不可以唯一确定一棵二叉树

前序和中序遍历不可以唯一确定一棵二叉树

```

逻辑：左子树->根->右子树

特点：中序遍历的第一个节点是最左边的节点（跟深度无关）最左边的节点。

可以结合前序遍历，前序找根，中序中在跟的左边为根的左子树，右边为右子树，然后接着丛前序中找左子树的根节点，对应中序中找出左右子树，这样就可以唯一的确定一颗二叉树。

代码

```C++
    void InOrder(TreeNode* root){
        if(root!=NULL){
            InOrder(root->left);
            vist(root);
            InOrder(root->right);
        }
    }
```