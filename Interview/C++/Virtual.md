# 虚函数：虚函数的作用域与实现原理 什么是虚函数 有什么作用

C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。
**静态多态通过重载、模板来实现**；
**动态多态就是通过本文的主角虚函数来体现的。**

* 虚函数实现原理 :
  `包括虚函数表、虚函数指针等`

```md
    虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址

```

* 结论

```md
    每个声明了虚函数或者继承含有虚函数的类都会有一个自己的vtbl（虚函数表）
    同时该类的每个对象都会包含一个vtpr指向自己的vtbl
    虚函数按照自己声明的顺序存放于vtbl表中，vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数
    如果子类覆盖了父类的虚函数，将被放到虚表中原来父类虚函数的位置
    多继承时，如果所继承的每个父类都含有自己的虚函数表，那么子类的虚函数表放入继承的第一个父类的虚函数表中

```

## 多继承时需要注意什么

多继承时需要注意派生类的构造函数初始值也只能初始化它的直接基类;基类的构造顺序与派生列表中基类出现顺序一致,与派生类构造函数初始化列表无关.
单继承,类派生列表明确指出他是从那个基类

## 为什么C++里访问虚函数比普通函数慢

```md
    单继承时差不多，多继承时会慢
```

### 调用性能问题

```md
    通过对象的vptr找到类的vtbl，这是一个简单的操作，因为编译器知道可以在哪找到vtpr（指针偏移调整），一个间接寻址（得到vtbl），代价可以忽略不计，通过vtbl找到被调用函数的指针，（代价：指针的偏移调整）
    调用被调用的函数
    单继承的情况下，调用虚函数所需的代价几乎和调用普通函数的代价相同，
    在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。 虚函数运行时所需的代价主要是虚函数不能是内联函数。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。

```

### 占用空间问题

```md
    编译器会给每个包含虚函数或继承虚函数的类分配一个vtbl（扩大了类的体积）当然如果只有一两个虚函数接口，这种内存消耗较少，但是如果有很多类和类中有很多虚函数，这个开销是很大的（虚函数表中是几个函数指针的大小），但这也不是主要的开销，最主要的是父类中含有很多虚函数接口，但是子类继承父类，只需要覆盖其中的几个虚函数接口，子类的vtbl其余内容就会和父类重复，这在很多子类继承和父类中很多虚函数造成很大一部分内存空间浪费，
    由于虚函数中vtpr的存在，虚函数也会增加该类的每个对象的体积，单继承或者没有继承的条件下类的对象会多一个vtpr指针（4个字节），在多继承的情况下，继承N个父类，同时N个父类都有自己的vtpr，类的每个对象会多N个vtpr，也就是（4N个字节），当一个类的对象大小较小的时候，这种情况不明显，但是本身对象较小时，这种内存消耗就大了。
```

## 纯虚函数

**纯虚函数**是在基类中声明的虚函数，在基类中不定义，但要求任何派生类都要对该函数进行定义，在基类中声明时，需要在函数后面加上`=0`

示例：

`virtual ReturnType func(paraType)=0;`

**为什么需要纯虚函数：**

1. 为了方便使用多态，我们通常在基类中声明虚函数
2. 在某种情况下，基类生成对象是不合理的。动物作为基类，老虎作为派生类，动物是不能生成对象的，相反老虎可以生成对象。

所以定义纯虚函数的概念，将函数定义为虚函数，编译器要求必须要在派生类中予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，不能生成实例。只能创建派生类的实例。

**纯虚函数的意义**就是让所有的派生类对象都能够执行纯虚函数的动作。

## 为什么需要虚析构函数，什么时候不需要？父类的虚析构函数为什么要定义为虚函数

**前提：** 编译器在编译时，构造是从里向外构造（从基类开始构造一层层直到构造到派生的最底层的类），在析构时是从外向内析构，（先析构派生类，然后在析构父类）
当使用一个基类的指针删除一个派生类的对象时，只有将基类的析构函数虚掉，这样才会顺利的调用子类的析构函数完之后，回来调用基类的析构函数（不会造成内存泄漏）

当然也不可以随意将析构函数声明为虚函数，必定不必要这样，而非要这样的话，会造成内存上的浪费，上文有解释。只有是基类，并且有派生类继承时将析构函数声明为虚函数

## 内联函数，构造函数，静态成员函数可以是虚函数嘛

```md
    inline不能接virtual函数 因为他是在编译时展开的，必须拥有实体
    static不能接virtual函数 因为是属于class自己的，也必须拥有实体
    constructor 不能是virtual函数，因为constructor如果是虚函数的话，调用时也需要根据vtable寻找，但是constructor本身都是virtual的，所以是查找不到的，无法创建实例，类中的成员是都访问不到的。因此constructor是无法内联的。
    inline函数是在编译时，将函数调用的指令替换成函数，以此来降低函数调用时带来的成本，但是如果是虚函数的话，虚函数是在运行时才知道具体是那个函数，所以没法对编译时进行inline展开，但是如果通过对象调用虚函数是可以inline的，大多数虚函数是通过指针或引用来调用的，所以virtual函数实际是无法inline的
    static的函数是属于某个类的，而不是某个对象的，同时其函数指针的存放也不同于其他函数指针（他是存放在堆中的也就是静态数据区）
```

## 构造函数可以调用虚函数嘛

不能，因为如果在构造函数中调用虚函数，实际上不是调用自己的虚函数，而是调用的父类的虚函数，因为自己本身还未构造好，多态是disable的

## 虚函数中一些常见的问题

1. 虚函数是动态绑定的，使用虚函数的指针或引用可以找到实际类的对应函数，而不是执行定义类的函数。
2. 构造函数中不能调用虚函数，因为实际调用的虚函数是父类的对应函数，自己还没构建好，堕胎是disable的
3. 析构函数一般都是虚函数
4. 将一个虚函数定义为纯虚函数，实际上将这个类定义为抽象类，无法实例化对象。
5. 纯虚函数可以拥有定义体
6. 析构函数可以纯虚化，但必须拥有定义体，因为析构函数的调用是在子类中进行的。
7. 派生类的override虚函数声明必须要和父类的虚函数一致，除非，父类虚函数返回类型为指针或者引用，子类虚函数中可以返回指针或引用的派生。

示例

```C++
virtual Base* clone();
virtual Derived* clone();
//这种方式是对clone方法非常有效的
```

## 为什么需要虚继承

虚拟继承是多重继承中特有的概念，是因为多重继承而出现的。
举例：D类继承于B1,B2两个类，B1，B2又同时继承于A类，因此D类中两次出现A类的变量和函数，因此可以将B1，B2对A的继承定义为虚拟继承，A也就成了虚拟基类，
虚拟继承的特点，任何派生类中的virtual基类总用同一个（共享）对象来表示。
