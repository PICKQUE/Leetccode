# 指针

## 防止指针的越界使用

1. 防止数组越界
2. 防止向一块内存中拷贝过多的内容
3. 防止使用空指针
4. 防止对const进行修改
5. 防止改变指向静态存储区的内容
6. 防止两次释放一个指针
7. 防止使用野指针

## 如何检测内存越界、野指针

GFlags 检查内存越界、野指针等

打开检查功能： gflags /p /enable  **.exe /full

关闭检查功能： gflags /p /disable  **.exe

列出当前启动了页堆的进程列表 : gflags /p

## 指针退化

用数组作为函数参数那么数组就会退化成指针

```C++
    void func(char a[100]){
        cout<<sizeof(a);// 4
    }
```

修改为传入数组的引用来解决问题

```C++
    void func(int (&a[100])){
        cout<<sizeof(a); // 10
    }
```

## 指针的移动问题

指针`p++`，`p`移动了指针指向变量类型的大小。

## 堆和栈上的指针

1. 在堆上的指针为堆指针，可以保存在全局数据结构中，供不同函数访问同一块内存。
2. 在栈上的指针为栈指针，在栈（函数）退出之后，该内存不会被访问。

## 指针作为函数的参数，函数指针

指针作为函数参数 `ptr`

```C++
    void func(type* ptr);
```

函数指针(func)

```C++
    void (*func)(type* ptr);
```

## 指针和引用及地址的区别，数组名

指针意味着已经有一个指针变量存在,他的值是一个地址，指针变量本身也存放在一个长度为四个字节的地址当中，而地址本身并不代表有任何变量存在

地址表示内存的位置点，它是用来赋给指针的，地址本身没有大小的概念，指针指向变量的大小，取决于地址后面存放的变量类型。

## 指针与数组名之间的区别

两者都是指针，前者可以改变，后者不可以改变（Type* const ArrayName）。

## 指针和引用之间的区别

**相同点**：都是内存的概念

**不同点**：指针指向一块内存，他的内容是所指内存的地址，引用是某块内存的别名

区别：

1. 指针是一个实体，而引用是个别名。
2. 引用使用时无需解引用（*），指针需要解引用
3. 引用只能 在定义时被初始化一次，之后不可变，指针可变。
4. 引用没有const，指针有const（type* const ptr）
5. 引用不能为空，指针可以为空
6. sizeof(引用)得到的是对象的大小，sizeof（指针）得到的是指针本身的大小。
7. 指针和引用的自增（++）运算意义不一样
8. 从内存分配上看，程序为指针变量分配内存区域，而引用不需要分配内存区域

## 指针四要素

1. 指针变量,表示一个内存地址,通常为逻辑地址,与实际的物理地址还有一个**映射**关系
2. 指针变量的长度,在WIN_32环境下通常为4个字节大小
3. 指针指向的变量,具体内容可能是各种类型的变量
4. 指针指向的变量的长度,以该内存地址空间开始的内存空间的大小
