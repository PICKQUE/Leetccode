# shared_ptr与weak_ptr

使用shared_ptr控制对象的生命周期，常用来进行对象的创建，属于强引用，只要被shared_ptr引用该对象就不会被析构

weak_ptr是一种弱引用，常常用来侦查对象是否存在，不控制对象的生命期，
也不会增加对象的引用计数如果对象还存在没被析构那么可以通过成员函数进行提升为强引用

shared_ptr = weak_ptr.lock（）

提升和引用计数都是原子操作的。

scope_ptr可以解决重复释放内存泄漏

 Shared_ptr::reset()函数若没有传入参数，那么智能指针会停止对保存指针的所有权的共享，
共享资源的引用计数减一。如果传入一个对象则释放当前的对象，去管理新传入的对象  

## 关于多线程如何避免访问已经释放的内存

```C++

#include<iostream>
#include<thread>
#include<mutex>
#include<memory>

using namespace std;
class A{
    public:
        A(){}
        ~A(){
            cout<<"destructor"<<endl;
        }
        void func(){
            cout<<"A function"<<endl;
        }
};
void handle(weak_ptr<A> p){
    //弱指针转换成强指针
    shared_ptr<A> q=p.lock();
    if(q!=nullptr){
        q->func();
    }else{
        cout<<"A already destructor"<<endl;
    }
}
int main(){
    shared_ptr<A> p(new A());
    thread t1(handle,p);
    return 0;
} 
```

## 如何解决循环引用所导致的内存泄露问题

解决循环引用需要将引用的其中一方换成弱引用
```C++
#include<iostream>
#include<memory>

using namespace std;

class children;
class parent;

typedef shared_ptr<children> children_ptr;
typedef shared_ptr<parent> parent_ptr;

class parent{
  public:
  children_ptr children;
  ~parent(){cout<<"parent destructor"<<endl;}
};
class children{
  public:
    weak_ptr<parent> parent;
    ~children(){cout<<"childrent destructor";}
};

void test(){
  children_ptr c(new children());
  parent_ptr p(new parent());

  c->parent=p;
  p->children=c;
  
  cout<<c.use_count()<<endl;
  cout<<p.use_count()<<endl;
}
int main(){
  test();
  getchar();
  return 0;
}
```