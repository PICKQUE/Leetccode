# 知识点

## 关系型数据库与非关系型数据库的区别

### 非关系型数据库的优势

**性能**NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。

**可扩展性**同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
关系型数据库的优势：

**复杂查询**可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。

**事务支持**使得对于安全性能很高的数据访问要求得以实现。

对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

## 事务四大特性

1. 原子性
2. 一致性
3. 隔离性
4. 持久性

## 数据库的隔离级别，每个级别会引发什么问题

1. 未提交读
2. 提交读
3. 可重复读
4. 可串行化

## MySQL默认的隔离级别时可重复读

并发一致性问题：

* 丢失修改
* 脏读数据
* 不可重复读
* 幻读
  
## 锁的分类

**悲观锁**他对于数据被外界修改保持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁，悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁，都是悲观锁

* 悲观锁（按照使用性质划分）
  * 共享锁 也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。
  * 排它锁 也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。
  * 更新锁 用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。
* 悲观锁（按照作用范围划分）
  * 行锁：锁的作用范围是行级别，数据库能够确定哪些行需要所得情况下使用行锁，如果不知道会影响那些行的时候会用表锁
  * 表锁：所得作用范围是整张表
**乐观锁**每次自己操作数据的时候认为没有人回来修改它，所以不去枷锁，但是在更新的时候回去判断在此期间数据没有被修改。
* 乐观锁实现方式
  * 版本号，就是给数据增加一个版本表示。
  * 时间戳，通过时间戳来进行判断，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。
  * 待更新字段，和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息。
  * 所有字段，和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

## 数据库三范式

* 第一范式 属性不可分
* 第二范式（每个非主属性完全依赖于键码）
* 第三范式（非主属性不传递函数依赖于键码）

## 内连接、外连接、交叉连接

* 概念: 根据两个表或多个表的列之间的关系，从这些表中查询数据。分为三种：内连接，外连接，交叉连接
* 目的：实现多个表查询操作

* 内连接：仅将两个表中满足连接条件的行组合起来作为结果集。在内连接中，只有两个表中匹配的行才能在结果集中出现。
  * 等值连接
  * 自然连接
  * 不等连接
* 外连接：在内连接的基础上，还包含表中所有不符合条件的数据行，并将相对应的表列填写NULL
  * 左外连接（LEFT OUTER JOIN或LEFT JOIN）
  * 右外连接（RIGHT OUTER JOIN或RIGHT JOIN）
  * 全外连接（FULL OUTER JOIN或FULL JOIN）
* 交叉连接：没有WHERE子句，他返回连接表中所有数据行的笛卡尔积

* MYSQL的两种存储引擎区别（事务，锁级别等等），各自的适用场景
  * 事务 InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
  * 并发 MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
  * 外键 InnoDB支持外键
  * 备份 InnoDB支持在线热备份
  * 崩溃恢复 MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且回复的速度也更慢
  * 其他特性 MyISAM支持压缩表和空间数据索引
* 应用场景
  * MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
  * InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

MySQL常见索引类别有：主键索引、唯一索引、普通索引、全文索引、组合索引

* PRIMARY KEY（主键索引）
* UNITQUE（唯一索引）
* INDEX（普通索引）
* FULLTEXT（全文索引）
* 组合索引

MySQL各种索引区别：

* 普通索引：最基本的索引，没有任何限制
* 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
* 主键索引：它是一种特殊的唯一索引，不允许有空值。
* 全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时耗空间
* 组合索引：为了更多的提高MySQL效率可建立组合索引，遵循“最左前缀”规则

索引有B+索引和hash索引，各自的区别

* BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量；如果一通配符开头，或者没有使用常量，则不会使用索引。
* Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端：

1. Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。
2. 联合索引中，Hash索引不能利用部分索引键查询。
对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。
3. Hash索引无法避免数据的排序操作
由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。
4. Hash索引任何时候都不能避免表扫描
Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。
5. Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高
对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。

B+索引数据结构，和B树的区别

MySQL数据库用过吧？I里面的索引是基于什么数据结构
答：主要是基于Hash表和B+树，

聚焦索引和非聚焦索引区别

两者的根本区别是表记录的排列顺序和与索引顺序是否一致。

1. 聚焦索引一个表只能有一个，而非聚焦索引一个表可以存在多个
2. 聚焦索引存储记录是物理上连续存在，而非聚焦索引是逻辑上的连续，物理存储并不连续
3. 聚焦索引查询数据速度快，插入数据速度慢；非聚焦索引反之

数据库的优化（从sql语句优化和索引两个方面考虑）

1. 优化insert语句：一次插入多值；
2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描；
3. 应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；
4. 优化嵌套查询：子查询可以被更有效率的连接(Join)替代；
5. 很多时候用 exists 代替 in 是一个好的选择。

数据库表结构的优化
    数据库表机构的优化包括选择合适数据类型，表的范式优化，表的垂直拆分和表的水平拆分等手段

系统配置的优化

* 操作系统配置的优化：增加TCP支持的队列数
* mysql配置文件的优化：Innodb缓存池设置（innodb_buffer_pool_size，推荐总内存的75%）和缓存池的个数（innodb_buffer_pool_instance）

使用explain优化sql和索引

使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。

* select_type : 查询类型，有简单查询、联合查询、子查询等
* key : 使用的索引
* rows : 扫描的行数

数据库的主从复制

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

* binlog 线程 ：负责将主服务器上的数据更改写入二进制文件（binlog）中。
* I/O 线程 ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。
* SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。
